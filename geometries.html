 
<!DOCTYPE html>
<html lang="en">
  <head>

    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link rel="icon" href="../../favicon.ico">
   
    <title>VirtualStoryCraft</title>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
    

    <!-- Bootstrap theme -->
   

    <script src="js/jquery-2.1.3.js"></script>
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.css">
	<!-- Optional theme -->
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap-theme.css">
		 <link href="css/layout.css" rel="stylesheet">
	<!-- Latest compiled and minified JavaScript -->
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
	<script src="https://cdn.firebase.com/js/client/2.2.1/firebase.js"></script>
	<script src="js/Detector.js"></script>
 
  </head>
  
 <body>
 	<div class="container-fluid col-md-12">
		<script src="//cdnjs.cloudflare.com/ajax/libs/three.js/r69/three.min.js"></script>
				<script src="js/controls/OrbitControls.js"></script>
	</head>
	<body>
	<div id="box"></div>
	<div id="sphere"></div>
	<div id="pyramid"></div>
	<div id="cylinder"></div>
		<script>
			
			var manualControl = false;
			var longitude = 0;
			var latitude = 0;
			var savedX;
			var savedY;
			var savedLongitude;
			var savedLatitude;
			
			var position = {x:0, y:0, z:0};
	
			
			
			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var apps = [];

			init();
			animate();

			function init() {

				var w = 300;
				var h = 200;

				var fullWidth = w * 2;
				var fullHeight = h * 2;

				apps.push( new App( 'box', fullWidth, fullHeight, w * 0, h * 0, w, h ) );
				apps.push( new App( 'sphere', fullWidth, fullHeight, w * 1, h * 0, w, h ) );
				apps.push( new App( 'pyramid', fullWidth, fullHeight, w * 0, h * 1, w, h ) );
				apps.push( new App( 'cylinder', fullWidth, fullHeight, w * 1, h * 1, w, h ) );

			}

			function animate() {

				for ( var i = 0; i < apps.length; ++i ) {

					apps[ i ].animate();

				}

				requestAnimationFrame( animate );

			}

			function App( containerId, fullWidth, fullHeight, viewX, viewY, viewWidth, viewHeight ) {

				var container, stats;

				var camera, scene, renderer;

				var mesh, group1, group2, group3, light;

				var mouseX = 0, mouseY = 0;

				var windowHalfX = window.innerWidth / 2;
				var windowHalfY = window.innerHeight / 2;

				init();
				
				
			function init() {

					container = document.getElementById( containerId );
					renderer = new THREE.WebGLRenderer( { antialias: true } );
					renderer.setClearColor( 0xffffff );
					renderer.setSize( container.clientWidth, container.clientHeight );
					container.appendChild( renderer.domElement );
	
					camera = new THREE.PerspectiveCamera( 20, container.clientWidth / container.clientHeight, 1, 10000 );
					camera.setViewOffset( fullWidth, fullHeight, viewX, viewY, viewWidth, viewHeight );
					camera.position.z = 1800;

					scene = new THREE.Scene();

					/*light = new THREE.DirectionalLight( 0xffffff );
					light.position.set( 0, 0, 1 ).normalize();
					scene.add( light );*/

					// shadow

					var canvas = document.createElement( 'canvas' );
					canvas.width = 128;
					canvas.height = 128;

					var context = canvas.getContext( '2d' );
					var gradient = context.createRadialGradient( canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2 );
					gradient.addColorStop( 0.1, 'rgba(210,210,210,1)' );
					gradient.addColorStop( 1, 'rgba(255,255,255,1)' );

					context.fillStyle = gradient;
					context.fillRect( 0, 0, canvas.width, canvas.height );
					

				

					var controls = new THREE.OrbitControls( camera, renderer.domElement );

					// shadow

					var canvas = document.createElement( 'canvas' );
					canvas.width = 128;
					canvas.height = 128;


					context.fillStyle = gradient;
					context.fillRect( 0, 0, canvas.width, canvas.height );

					switch (containerId){
						case "box": //"box":
						
						$("#box").append(createBox(scene, position));
						
						break;
						case "pyramid":
						
						$("#pyramid").append(createPyramid(scene, position));
						
						break;
						
					}

					
					

					var faceIndices = [ 'a', 'b', 'c', 'd' ];

					var color, f1, f2, f3, p, n, vertexIndex;

						


					var materials = [

						new THREE.MeshLambertMaterial( { color: 0xffffff, shading: THREE.FlatShading, vertexColors: THREE.VertexColors } ),
						new THREE.MeshBasicMaterial( { color: 0x000000, shading: THREE.FlatShading, wireframe: true, transparent: true } )

					];


					

					document.addEventListener( 'mousemove', onDocumentMouseMove, false );

				
				}//init

				function onDocumentMouseMove( event ) {

					mouseX = ( event.clientX - windowHalfX );
					mouseY = ( event.clientY - windowHalfY );

				}

				//

				this.animate = function() {

					render();
					//stats.update();

				};

				function render() {

					camera.position.x += ( mouseX - camera.position.x ) * 0.05;
					camera.position.y += ( - mouseY - camera.position.y ) * 0.05;

					camera.lookAt( scene.position );

					renderer.render( scene, camera );

				}


			} //APp
			
			// listeners
			document.addEventListener("mousedown", onDocumentMouseDown, false);
			document.addEventListener("mousemove", onDocumentMouseMove, false);
			document.addEventListener("mouseup", onDocumentMouseUp, false);
			
        
        function createSphere(scene, pos, texture){
				// creation of a big sphere geometry
				var sphere = new THREE.SphereGeometry(50,50,50);
				sphere.applyMatrix(new THREE.Matrix4().makeScale(-1, 1, 1));
				// creation of the sphere material
				if(texture!= undefined){}
				var sphereMaterial = new THREE.MeshBasicMaterial({color:"blue"});			
				sphereMaterial.side =THREE.DoubleSide;
				var sphereMesh = new THREE.Mesh(sphere, sphereMaterial);
				sphereMesh.position.y = pos.y;
				scene.add(sphereMesh);
			
				return sphere;
			}
       
		function createBox(scene, pos, texture){

			var box = new THREE.BoxGeometry(50,50,50);		
			var meshFaceMaterial1 = new THREE.MeshBasicMaterial({color:"red"} );//new THREE.MeshFaceMaterial( materialArray );
			meshFaceMaterial1.side = THREE.DoubleSide;
			var dh_mesh_inside = new THREE.Mesh(box, meshFaceMaterial1);
			dh_mesh_inside.position.y = pos.y;
			scene.add(dh_mesh_inside);
			return box;
		}
		        
       	function createCylinder(scene, position, texture){	
			var cylinder = new THREE.CylinderGeometry(50, 50, 100, 100, false); 		
			var cylinderMesh = new THREE.Mesh( cylinder, new THREE.MeshBasicMaterial( {	color:"yellow",side:THREE.DoubleSide}))	;//,vertexColors: THREE.FaceColors}));	
			cylinderMesh.rotation.y = 45 * Math.PI / 180;
			cylinderMesh.position.y= pos.y;
			scene.add(cylinderMesh);
			return cylinder
		}    
		
		function createPyramid(scene, pos, texture){

	
			var pyramid = new THREE.CylinderGeometry(0, 50, 50, 4, false); 		
			var faceColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00];
			faceColors.forEach( function(color, idx) 
				{ pyramid.faces[2 * idx + 1].color.setHex(color);});	
			var pyramidMesh = new THREE.Mesh( pyramid, new THREE.MeshBasicMaterial( {	vertexColors: THREE.FaceColors,side:THREE.DoubleSide}))	;//,vertexColors: THREE.FaceColors}));		
			//pyramidMesh.rotation.y = 45 * Math.PI / 180;
			pyramidMesh.position.y = pos.y;
			scene.add(pyramidMesh);
			
			return scene;
		}
		
		
               function loadTexture(geo){
            
				var front = [new THREE.Vector2(0, .666), new THREE.Vector2(.5, .666), new THREE.Vector2(.5, 1), new THREE.Vector2(0, 1)];
				var back =  [new THREE.Vector2(.5, .666), new THREE.Vector2(1, .666), new THREE.Vector2(1, 1), new THREE.Vector2(.5, 1)];
				var sideR = [new THREE.Vector2(0, .333), new THREE.Vector2(.5, .333), new THREE.Vector2(.5, .666), new THREE.Vector2(0, .666)];
				var sideL = [new THREE.Vector2(.5, .333), new THREE.Vector2(1, .333), new THREE.Vector2(1, .666), new THREE.Vector2(.5, .666)];
				var top	 =  [new THREE.Vector2(0, 0), new THREE.Vector2(.5, 0), new THREE.Vector2(.5, .333), new THREE.Vector2(0, .333)];
				var bottom =[new THREE.Vector2(.5, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, .333), new THREE.Vector2(.5, .333)];
				
				geo.faceVertexUvs[0] = [];
				
				geo.faceVertexUvs[0][0] = [ front[0], front[1], front[3] ];
				geo.faceVertexUvs[0][1] = [ front[1], front[2], front[3] ];
				  
				geo.faceVertexUvs[0][2] = [ back[0], back[1], back[3] ];
				geo.faceVertexUvs[0][3] = [ back[1], back[2], back[3] ];
				  
				geo.faceVertexUvs[0][4] = [ sideR[0], sideR[1], sideR[3] ];
				geo.faceVertexUvs[0][5] = [ sideR[1], sideR[2], sideR[3] ];
				  
				geo.faceVertexUvs[0][6] = [ sideL[0], sideL[1], sideL[3] ];
				geo.faceVertexUvs[0][7] = [ sideL[1], sideL[2], sideL[3] ];
				  
				geo.faceVertexUvs[0][8] = [ new THREE.Vector2(0, 0), new THREE.Vector2(.5, 0), new THREE.Vector2(0,.333) ];
				geo.faceVertexUvs[0][9] = [ new THREE.Vector2(.5, 0), new THREE.Vector2(.5, .333), new THREE.Vector2(0,.333)];
				  
				geo.faceVertexUvs[0][10] = [ bottom[0], bottom[1], bottom[3] ];
				geo.faceVertexUvs[0][11] = [ bottom[1], bottom[2], bottom[3] ];
			
			return geo;
            
            }

			// when the mouse is pressed, we switch to manual control and save current coordinates
			function onDocumentMouseDown(event){

				event.preventDefault();

				manualControl = true;

				savedX = event.clientX;
				savedY = event.clientY;

				savedLongitude = longitude;
				savedLatitude = latitude;

			}

			// when the mouse moves, if in manual contro we adjust coordinates
			function onDocumentMouseMove(event){

				if(manualControl){
					longitude = (savedX - event.clientX) * 0.1 + savedLongitude;
					latitude = (event.clientY - savedY) * 0.1 + savedLatitude;
				}

			}

			// when the mouse is released, we turn manual control off
			function onDocumentMouseUp(event){

				manualControl = false;

			}
			
			// pressing a key (actually releasing it) changes the texture map
			document.onkeyup = function(event){
						
    	}
			
		</script>
	</body>
</html>